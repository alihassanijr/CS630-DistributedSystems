#!/usr/bin/env python3

import os
import multiprocessing as mp
from multiprocessing import Process

from src.commons import lag
from src.mw.socket import RequestSocket, ReplySocket
from src.response import Response
from src.node import get_node, setup_head_daemon, register_node
from src.configuration import config

import logging

logging.basicConfig(format="%(levelname)s:%(message)s", level=logging.INFO)
_logger = logging.getLogger(__name__)

node = get_node()
None if not node.is_head() else setup_head_daemon(node)

def incoming_routine():
    _logger.info("Starting message service")
    from src.master.handler import handle_message
    sock = ReplySocket(hostname="0.0.0.0", port=config.req_port)
    sock.open()
    while True:
        _logger.info("Checking for messages")
        message = sock.receive()
        #message = sock.receive_nb()
        if message is not None:
            _logger.info(f"Head received message: {message}")
            response = handle_message(node, message)
            _logger.info(f"Head responding with: {response}")
            sock.send(response)
            _logger.info("Sent response.")

    sock.close()


def scheduling_routine():
    _logger.info("Starting scheduler")
    from src.master.scheduler import try_assign_job
    from src.master.job import update_job, get_remaining_jobs
    while True:
        _logger.debug("Checking scheduler")
        jobs = get_remaining_jobs(node)
        if jobs is not None and len(jobs) > 0:
            for job in jobs:
                status, job = try_assign_job(node, job)
                if status:
                    succ = update_job(node, job)
                    if not succ:
                        raise RuntimeError(f"Updating job failed: {job}")
        lag(config.scheduler_lag)


if __name__ == "__main__":
    register_node(node=node)

    if node.is_head():
        # This is a head node
        _logger.info("Starting head node service.")
        mp.set_start_method('spawn')

        processes = [
            Process(target=incoming_routine),
            Process(target=scheduling_routine),
        ]
        for p in processes:
            p.start()
        #incoming_routine(node)
        #scheduling_routine(node)
        #lag(config.head_daemon_lag)
        for p in processes:
            p.join()


    elif node.is_compute():
        from src.compute.handler import handle_message
        # This is a compute node
        _logger.info("Starting child node service.")

        head_sock = RequestSocket(timeout=config.request_timeout, hostname="0.0.0.0", port=config.rep_port)
        head_sock.open(node.master_addr, config.req_port)
        sock = ReplySocket(hostname="0.0.0.0", port=config.req_port)
        sock.open()

        while True:
            _logger.info("Waiting for message")
            message = sock.receive()
            _logger.info(f"Received message: {message}")
            response = handle_message(node, message)
            _logger.info(f"Handled message: {response}")
            sock.send(response)
            _logger.info("Sent response.")

        head_sock.close()
        sock.close()

    else:
        raise NotImplementedError(f"Server type not recognized. This should not have happened!")
